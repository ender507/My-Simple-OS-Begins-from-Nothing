# 实验项目4

## 个人信息(github version)

- 专业：18级计算机科学二班 
- 学号：18340057
- 姓名：ender507

## 实验题目

具有中断处理的内核

## 实验目的

1. PC系统的中断机制和原理

2. 理解操作系统内核对异步事件的处理方法

3. 掌握中断处理编程的方法

4. 掌握内核中断处理代码组织的设计方法

5. 了解查询式I/O控制方式的编程方法

## 实验要求

1. 知道PC系统的中断硬件系统的原理

2. 掌握x86汇编语言对时钟中断的响应处理编程方法

3. 重写和扩展实验三的的内核程序，增加时钟中断的响应处理和键盘中断响应。

4. 编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性

## 实验内容

1. 编写x86汇编语言对时钟中断的响应处理程序：设计一个汇编程序，在一段时间内系统时钟中断发生时，屏幕变化显示信息。在屏幕24行79列位置轮流显示’|’、’/’和’\’(无敌风火轮)，适当控制显示速度，以方便观察效果，也可以屏幕上画框、反弹字符等，方便观察时钟中断多次发生。将程序生成COM格式程序，在DOS或虚拟环境运行。

2. 重写和扩展实验三的的内核程序，增加时钟中断的响应处理和键盘中断响应，在屏幕右下角显示一个转动的无敌风火轮，确保内核功能不比实验三的程序弱，展示原有功能或加强功能可以工作.

3. 扩展实验三的的内核程序，但不修改原有的用户程序，实现在用户程序执行期间，若触碰键盘，屏幕某个位置会显示”OUCH!OUCH!”。

4. 编写实验报告，描述实验工作的过程和必要的细节，如截屏或录屏，以证实实验工作的真实性

## 实验过程

​		考虑到这次实验时间比较充裕（延长了一周），并且实验课老师阐述了之前实验的基本做法，我对之前的实验有了新的理解，这次对之前的操作系统进行了较大的改写和移植。考虑到这次实验的“风火轮”需要展示动态效果，我录制了演示视频在打包文件中。另外，很多过程不需要详尽的解释，我将代码解释简单地写在了注释里，之后的解释段落就不再赘述。

​		首先是风火轮的演示。程序代码如下：

```assembly
;	fireWheel.asm
org 100h
_start:
	xor ax,ax					; AX = 0
	mov es,ax					; ES = 0
	mov word [es:20h],wheel		; 设置时钟中断向量的偏移地址
	mov ax,cs 
	mov word [es:22h],ax		; 设置时钟中断向量的段地址=CS
	mov ds,ax					; DS = CS
	mov es,ax					; ES = CS
```

​		在程序初始化的时候就要将时钟中断的代码进行复制。时钟中断是`int 8`，计算中断向量：`8*4 =  20h`，所以时钟中断对应的中断向量位置在`[0:20h]`到`[0:24h]`处。所以一开始先要将风火轮的代码段赋值给中断向量处。`wheel`为本代码段内的风火轮程序模块的偏移地址，赋值给`[0:20h]`，`cs`为代码段地址，赋值给`[0:22h]`。

```assembly
; 在屏幕右下角初始化风火轮开始的字符'-'	
	mov	ax,0B800h		; 文本窗口显存起始地址
	mov	gs,ax			; GS = B800h
	mov ah,0Fh			; 0000：黑底、1111：亮白字
	mov al,'-'			; AL = 显示字符值'-'
	mov [gs:((80*24+79)*2)],ax	; 屏幕第 24 行, 第 79 列
	jmp $				; 死循环
```

​		接下来是对风火轮的初始化。风火轮依次显示`-` `\` `|` `/`，旋转时需要依据当前字符状态来决定下一状态。这里我将初始值设置为`-`，使用直接给显存赋值的方法给屏幕第二十四行七十九列赋值。之后程序进入`jmp $`的死循环。在死循环下，程序依然能够正常地运作则说明时钟中断被成功地响应了。

```assembly
; 时钟中断处理程序
	delay equ 4			; 计时器延迟计数
	count db delay		; 计时器计数变量，初值=delay

wheel:
	dec byte[count]				; 递减计数变量
	jnz _end						; >0：跳转
	mov byte[count],delay		; 重置计数变量=初值delay
```

​		时钟中断出现的频率相当快，为了能更好地看清风火轮的显示情况，需要减小频率。这里我设置了一个`delay`变量，为4。`count`变量初始值为4，每次出现时钟中断时`wheel`模块被调用，对`count`变量进行递减操作。当`count`不为0时直接跳转至`_end`，即不进行风火轮的变形。否则继续执行之后的变形模块，同时`count`变量恢复初始值4。

```assembly
	mov al,byte[gs:((80*24+79)*2)]
	sub al,'-'
	jz	lu2rd
	mov al,byte[gs:((80*24+79)*2)]
	sub al,'\'
	jz	vtc
	mov al,byte[gs:((80*24+79)*2)]
	sub al,'|'
	jz	ru2ld
```

​		然后是变形模块。依据显存`byte[gs:((80*24+79)*2)]`的值，也就是风火轮当前字符的类型来分别跳转至不同的变形模块。

```assembly
hrz:	;现在字符为'/'，改为'-'
	mov byte[gs:((80*24+79)*2)],'-'
	jmp _end
lu2rd:	;现在字符为'-'，改为'\'
	mov byte[gs:((80*24+79)*2)],'\'
	jmp _end
vtc:	;现在字符为'\'，改为'|'
	mov byte[gs:((80*24+79)*2)],'|'
	jmp _end
ru2ld:	;现在字符为'|'，改为'/'
	mov byte[gs:((80*24+79)*2)],'/'
	jmp _end
```

​		`hrz`和`vtc`表示变为水平和竖直字符的情况，`lu2rd` `ru2ld`表示变为“左上到右下”和“右上到左下”的直线字符。在这里同一直接对显存进行赋值，然后跳转到`_end`模块。

```assembly
_end:
	mov al,20h					; AL = EOI
	out 20h,al					; 发送EOI到主8529A
	out 0A0h,al					; 发送EOI到从8529A
	iret						; 从中断返回
```

​		最后的`_end`模块中，现将`al`赋值为20h，表示EOI，即end of interrupt，中断终止，给8529A的20h和0A0h端口发送EOI，表示中断已经正确处理并已经结束，最后`iret`返回原来的执行位置。

​		演示截图如下（只截取了两张以演示风火轮会转动，之后的内核实现也包含风火轮功能）

![1](PIC\\1.png)

![2](PIC\\2.png)

​		在实现了风火轮之后很容易将其加入操作系统内核。

​		操作系统的代码实现如下：

```assembly
	;MBR.asm
org 7c00h
kernalPos equ 8100h		;将监控程序载入此地址
start:
	mov ax,cs
	mov es,ax		; ES = 0
	mov ds,ax		; DS = CS
	mov es,ax		; ES = CS
	
	mov ax,cs                ;段地址,存放数据的内存基地址
	mov es,ax                ;设置段地址（不能直接mov es,段地址）
	mov bx, kernalPos	 	 ;偏移地址, 存放数据的内存偏移地址
	mov ah,2                 ;功能号2,表示读入
	mov al,3                 ;扇区数
	mov dl,0                 ;驱动器号 ; 软盘为0，硬盘和U盘为80H
	mov dh,0                 ;磁头号 ; 起始编号为0
	mov ch,0                 ;柱面号 ; 起始编号为0
	mov cl,2				 ;2号扇区，即监控程序位置
	int 13H 				 ;调用读磁盘BIOS的13h功能,将监控程序读入
	
	jmp 0x800:0x100
	
afterRun:
	jmp $
```

​		首先是首扇区的引导程序。该部分被我进一步的精简化，现在只有利用BIOS调用`int 13H`将操作系统内核读入内存和进行跳转的部分。需要注意的是，在这次实验后，我的操作系统内核终于超过了一个扇区大小，即512Kb。所以在将软盘内容写入内存的时候需通过	`al`的大小来读入更多的扇区数。我这里写的是三，为之后的内核的拓展预留空间。同时在软盘里也会留下相应的空间，用户程序会在软盘内更靠后的位置。

​			之后是内核的c代码部分的实现。

​			受限是对汇编函数模块的声明和全局变量的定义

```c
/*	ckernal.c	*/
extern void _start();
extern void getChar();		//用于读取键盘输入
extern void putChar();		//打印字符
extern void cmdStr();		//打印提示输入指令的信息
extern void errorCmd();		//打印指令错误信息
extern void cls();			//清屏
extern void load();			//读入用户程序
extern void go();			//进入输入指令的模块
extern void _end();

char _ch = 'a';				//记录读入键盘的数据
char cmd[10] = "0123456789";//记录指令
int pos = 0;				//记录指令长度
int userPro = 0;			//选择用户程序
char color = 1;				//对Ouch!Ouch!键盘中断的颜色记录

```

​		引入的函数和全局变量的定义的详细的解释请看注释。这里需要特殊说明的是，这里记录键盘读入数据的字符变量`_ch`一开始我是命名为`ch`的。在正常的c语言编写时`ch`变量完全合法，但是在混编过程中如果用`gcc`编译得到的结果，变量名保持不变，`ch`是一个寄存器的名字，会导致未知的错误，这点需要注意。

```c

void decode(){
	if(cmd[0]=='r'&&cmd[1]=='u'&&cmd[2]=='n'){
		cls();
		if(cmd[4]=='a')userPro = 5;
		else if(cmd[4]=='b')userPro = 6;
		else if(cmd[4]=='c')userPro = 7;
		else if(cmd[4]=='d')userPro = 8;
		load();
		userPro = 0;
	}
	else if(cmd[0]=='c'&&cmd[1]=='l'&&cmd[2]=='s')cls();
	else {
		cls();
		errorCmd();
	}
	go();
}
```

​		在`decode`函数中，对指令进行解析。如果是`run`指令则对`userPro`进行赋值。用户程序有`a` `b` `c` `d`四个，存放的扇区分别为第5、6、7、8个扇区，直接对`userPro`进行扇区号的赋值，方便读入用户程序然后调用`load`函数读入并执行用户程序。如果是`cls`指令则进行清屏，否则调用`errorCmd`函数进行报错。

```c
void getCmd(){
	pos = 0;
	_ch = 'a';
	for(int i=0; i<10; i++)cmd[i] = ' ';
	getChar();
	while(_ch != 13){			//输入为回车（13）时表示指令输入完成，退出循环
		if(_ch == 8){			//输入为退格（8）时删去最后一个输入的字符
			_ch = ' ';
			pos--;				//指令位置减一，使得整个指令长度减一
			putChar();			//_ch为空格时putChar()，用空格覆盖掉上一个输入的字符
		}
		else{
			putChar();			//正常读入字符后将字符显示在屏幕上
			cmd[pos++]=_ch;
		}
		getChar();
	}
	decode();
}
```

​		`getCmd`函数中，让用户输入指令。`pos`记录当前指令的输入位置，`_ch`为当前输入的字符。通过汇编代码的`getChar()`读入键盘输入并存入`_ch`中。指令输入的标志为用户输入回车，即`\r`，`ascii`码为13。当读入的字符为回车时退出循环，否则在循环中一直读取字符。一般情况下，读入字符后写入`cmd[pos]`，然后`pos`递增，`putchar`函数将在屏幕第三行当前的`pos`位置处显示该字符。即做成有回显的键盘读入。有一种特殊情况是输入了退格，即`ascii`码值8。在这种情况下，将`_ch`赋值为空格，`pos`递减，表示指令长度减少一，然后再调用`putChar()`，将`_ch`在`pos`位置上打印出来。这样一来，空格将覆盖最后一次屏幕上打印出的指令的最后一个字符，即删去了最后一个字符，实现了退格的功能。

```c
void cmain(){
	cmdStr();
	getCmd();
	return;
}
```

​		最后是`cmain()`函数，在汇编入口模块进行一定的初始化后就会直接调用`cmain`函数。分别调用打印提示和获取指令两个模块。

​		然后是汇编模块的实现。汇编模块保留了原有的功能，并在此基础上新增了时钟中断和键盘中断。为了解释的连续性，且省去之前实验已经实现的、意义不大的模块，之后的代码解释不会按照原来的源代码文件的顺序解释。

```assembly
BITS 16
UserProPos equ 1000h		;将用户程序载入此地址
global _start				;代码入口
global cmdStr				;打印输入指令提示
global errorCmd				;指令错误提示
global cls					;清屏
global getChar				;从键盘读取字符并记录
global putChar				;向屏幕输出字符
global load					;读入并执行用户程序（包含键盘中断的改写和恢复）
global go					;调用cmain的入口
global _end

extern cmain
extern _ch					;读键盘后保存的字符
extern pos					;putChar打印的位置
extern userPro				;需要启用的用户程序所在的扇区
extern color				;控制Ouch!Ouch!信息的颜色
```

​		首先是声明全局的函数、变量，以及部分常量的定义、对c模块中的变量的引入。详见注释。

​		下面开始解释汇编代码的**时钟中断**部分。代码大体和之前的风火轮实现相同，代码部分不再重复解释。

```assembly
	mov	bx, es
	mov	ax, 0
	mov	es, ax
	mov word[es:20h],wheel	; 设置时钟中断向量的偏移地址
	mov ax,cs 
	mov word[es:22h],ax	; 设置时钟中断向量的段地址=CS
	mov	es, bx
```

​		函数的入口模块，对各个段进行初始的定义之后需要对时钟中断向量进行改写。将`[0:20h]`和`[0:22h]`分别赋值为时钟中断发生时执行代码的代码偏移和代码段。分析见之前的风火轮的单独实现的部分。

```assembly
; 在屏幕右下角初始化风火轮开始的字符'-'	
	mov		ax,0B800h		; 文本窗口显存起始地址
	mov		gs,ax			; GS = B800h
	mov 	ah,0Fh			; 0000：黑底、1111：亮白字
	mov 	al, '-'			; AL = 显示字符值'-'
	mov 	[gs:((80*24+79)*2)],ax	; 屏幕第 24 行, 第 79 列
	
	...
	
	cls:
	mov	ax, 0600h	; AH = 6,  AL = 0				
	mov	bx, 0700h	; 黑底白字(BL = 7)
	mov	cx, 0		; 左上角: (0, 0)
	mov	dx, 184fh	; 右下角: (24, 79)	
	int	10h		; 显示中断
				; AH=06H表示将cx（左上角）dx（右下角）的矩形区域向上移动
	;wheel
	mov	ax, 0B800h		; 文本窗口显存起始地址
	mov	gs, ax			; GS = B800h
	mov 	ah, 0Fh			; 0000：黑底、1111：亮白字
	mov 	al, '-'			; AL = 显示字符值'-'
	mov [gs:((80*24+79)*2)], ax	; 屏幕第 24 行, 第 79 列
```

​		同样，风火轮需要初始化。需要注意的是，在清屏模块中，风火轮的字符也会被清除，导致出错。所以在清屏模块中，清空屏幕后需要对风火轮进行重新的初始化。如上段代码所示。

```assembly
; 时钟中断处理程序
	delay 	equ 4			; 计时器延迟计数
	count 	db delay		; 计时器计数变量，初值=delay
wheel:
	dec		byte[count]		; 递减计数变量
	jnz 	intEnd			; >0：跳转
	mov 	byte[count],delay	; 重置计数变量=初值delay
```

​		同样，时钟中断频率较大。为了防止风火轮转速过快看不清的情况发生，需要增加延迟。和之前单独实现风火轮的方法一样。

```assembly
	mov 	al,byte[gs:((80*24+79)*2)]
	sub 	al,'-'
	jz		lu2rd
	mov 	al,byte[gs:((80*24+79)*2)]
	sub 	al,'\'
	jz		vtc
	mov	 	al,byte[gs:((80*24+79)*2)]
	sub 	al,'|'
	jz		ru2ld
```

​		然后是根据当前位置显示的字符来选定下一个字符。和之前的风火轮相同。

```assembly
hrz:	;现在字符为'/'，改为'-'
	mov 	byte[gs:((80*24+79)*2)],'-'
	jmp 	intEnd
lu2rd:	;现在字符为'-'，改为'\'
	mov 	byte[gs:((80*24+79)*2)],'\'
	jmp 	intEnd
vtc:	;现在字符为'\'，改为'|'
	mov	 byte[gs:((80*24+79)*2)],'|'
	jmp 	intEnd
ru2ld:	;现在字符为'|'，改为'/'
	mov 	byte[gs:((80*24+79)*2)],'/'
	jmp 	intEnd
```

​		在改变字符后进入`intEnd`模块。

```assembly
intEnd:
	mov 	al,20h		; AL = EOI
	out 	20h,al		; 发送EOI到主8529A
	out 	0A0h,al		; 发送EOI到从8529A
	iret				; 从中断返回
```

​		将EOI发送给20h和0A0h两个端口后直接返回原来的执行位置。

​		接下来是**键盘中断**部分的解释。

```assembly
_start:
	...
	;对键盘中断原有的代码位置的保存
	mov	bx, es
	xor	ax, ax
	mov	es, ax
	cli		;执行操作时防止被中断打断
	push	word[es:24h]	;键盘中断偏移量入栈
	pop 	word[es:200h]	;键盘中断偏移量出栈给0:200h
	push 	word[es:26h]	;键盘中断代码段入栈	
    pop 	word[es:202h]	;键盘中断代码段出栈给0:202h
	sti
	mov	es, bx
	jmp	go
```

​		在函数入口模块`_start`中也要完成对键盘中断的初始化。在执行用户程序的时候需要利用键盘中断打印`Ouch!Ouch!`的字符，而用户程序执行后回到操作系统内核还需要能够继续输入指令，这说明在用户程序执行时，键盘中断执行的应该是我的操作系统设计好的代码，而在内核执行时就要变回来，使用原来的键盘中断，使得指令能够正常的读入。为了能够重新利用原有的键盘中断，需要将键盘中断的代码段和偏移量给保存起来。键盘中断为`int 9`，`9*4 = 36 = 24h`，故中断向量存储在`0:24h`到`0:27h`处。如上一段程序所示，分别存入`[es:200h]`和`[es:202h]`处。其中`cli`指令是声明不处理可屏蔽中断，防止这个过程被中断而可能出现错误。`sti`为声明重新接受可屏蔽中断。

```assembly
Ouch:
	mov	bp, OuchMes	; BP=当前串的偏移地址
	mov	ax, ds		; ES:BP = 串地址
	mov	es, ax		; 置ES=DS
	mov	cx, OuchMesLen ; CX = 串长
	mov	ax, 1301h	; AH = 13h（功能号）、AL = 01h（光标置于串尾）
	mov	bh, 00h		; 页号为0(BH = 0)
	mov bl, byte[color]
	inc	byte[color]
   	mov dh, 24		; 行号=24
	mov	dl, 0		; 列号=0
	int	10h		; 打印提示信息
	in 	al, 60h	
	jmp	intEnd
	
	...
	
	OuchMes:
    db 'Ouch!Ouch!'
	OuchMesLen  equ ($-OuchMes)
```

​		然后是`Ouch`模块，用来打印`Ouch!Ouch!`的提示信息。这里调用了BIOS的`int 10h`功能，打印一行字符在屏幕的24行。为了让效果更加明显，能多次反应键盘中断响应，我设计的程序中，键盘中断响应发生时`Ouch!Ouch!`的提示信息将会变色。`color`变量初始为1，每次经过键盘中断就加一，每次赋值给`bl`寄存器，即控制颜色的寄存器，由此来实现颜色变化。

​		需要注意的是，在按下一次按键后，会发生两次键盘中断：一次是按下去，一次是松开来。按和松都会引起键盘中断响应，也就是说会有两次颜色的变化，变一次色后马上会变第二次。

​		另外，原有的键盘中断中，键盘输入将会存储在60h的端口上作为缓冲，需要将其读出来，否则之后的键盘中断就会出错。所以在`jmp intEnd`向20h和0A0h发送EOI前需要`in al 60h`将60h端口上的值读出来。

```assembly
load:
	mov	bx, es
	xor	ax, ax
	mov	es, ax
	cli	
	mov 	word[es:24h],Ouch
	mov 	ax,cs 
	mov 	word[es:26h],ax	
	sti
	mov	es, bx

	mov	cl, byte[userPro]
	mov 	ax, cs		;段地址,存放数据的内存基地址
	mov 	es, ax		;设置段地址（不能直接mov es,段地址）
	mov 	bx, UserProPos  ;偏移地址; 存放数据的内存偏移地址
	mov 	ah, 2		;功能号2,表示读入
	mov 	al, 1		;扇区数
	mov 	dl, 0		;驱动器号 ; 软盘为0，硬盘和U盘为80H
	mov 	dh, 0		;磁头号 ; 起始编号为0
	mov 	ch, 0		;柱面号 ; 起始编号为0
	int 	13H		;调用读磁盘BIOS的13h功能
	call 	UserProPos
```

​		只有在用户程序执行时，才会有`Ouch!Ouch!`的信息打印，换句话说，只有用户程序执行的时候才要执行我自己写的键盘中断部分的代码。那么，在`load`模块中，调用用户程序之前应当先将`Ouch`模块的代码段和偏移量写入键盘中断响应的中断向量中。同样使用`cli`和`sti`防止被中断而出错。然后就正常地将用户程序从软盘中读入并且跳转执行。

```assembly
afterUser:
	mov	bx, es
	xor	ax, ax
	mov	es, ax
	cli	
    mov	ax, word[es:200h]
    mov word[es:24h], ax
    mov	ax, word[es:202h]
    mov	word[es:26h],ax
	sti	
	mov	es, bx
	jmp	go
```

​		在用户程序执行完后，回到操作系统内核，需要将原本的键盘中断给恢复，也就是将之前保存好的原有键盘中断相应的代码段和位移量赋值回键盘中断响应的中断向量处。

​		通过上述两种中断，本次实验要求实现的内容已经完成。下面是操作系统内核的**其他模块**的内容。

```assembly
getChar:
	mov		ah, 0
	int 	16h 		;0号功能调用从键盘读入一个字符放入al中
	mov 	byte[_ch], al
	ret
```

​		调用BIOS的`int 16h`读入键盘输入的字符存入`_ch`

```assembly
putChar:
	mov		ax, 0B800h	; 文本窗口显存起始地址
	mov		gs, ax		; GS = B800h
	mov 	ax, 3
	mov		bx, 80
	mul		bx
	add		ax, word[pos]
	mov 	bx, 2
	mul 	bx
	;经过上面的计算到此处，ax = (3*80 + pos)*2,对应位置第3行第pos列
	mov 	bp, ax
	mov 	ah, 0Fh
	mov 	al, byte[_ch]
	mov 	word[gs:bp], ax
	ret
```

​	 	通过直接计算屏幕位置对显存进行写入，在第三行的`pos`列打印字符`_ch`

​		剩下的`errorCmd` 和`cmdStr`都是通过`int 10h`调用在屏幕上显示字符串，不再赘述。

​		通过`gcc -c -m16 -march=i386 -masm=intel -nostdlib -ffreestanding -mpreferred-stack-boundary=2 -lgcc -fno-pie -shared ckernal.c -o ckernal.o`对c进行编译，`nasm -f elf32 kernal.asm -o kernal.o`对x86源码进行汇编，再通过`ld -m elf_i386 -N kernal.o ckernal.o -Ttext 0x100  --oformat binary -o kernal.bin`链接得到最后的可执行文件。利用`WinHex`写软盘后，使用虚拟机`VM Ware`执行。

​		**本次实验的中断处理代码都是动态过程，我在打包文件中放入了演示视频以更好地展示执行效果。**执行过程中的截图如下：

 		首先，风火轮能够正确的执行，说明时钟中断处理成功：

![3](PIC\\3.png)

![4](PIC\\4.png)

​	其次，在输入`run a`后，用户程序a启动，在过程中按下按键`Ouch!Ouch！`能够正常变色，说明键盘中断处理成功。在用户程序运行期间，风火轮也能继续旋转。

![5](PIC\\5.png)

![6](PIC\\6.png)

​		在用户程序执行完成后继续输入代码，还能正常运行，说明键盘中断被恢复。

## 实验总结

​		本次实验的难点在于键盘中断的操作。在时钟中断的操作中，只需要将代码段和代码偏移量的地址存入时钟中断对应的时钟中断向量即可。改变的时钟中断完全可以自由发挥，只要最后记得向8529A发送EOI信息。一开始我采取了同样的方式实现键盘中断，即在初始化时将自己写好的键盘中断时执行的代码的所在代码段和偏移量赋值给键盘中断向量，执行完成后向8529A发送EOI。但是马上就出现了问题：不仅"Ouch!Ouch!"不能显示出来，就连输入指令的操作都不能进行。

​		按理说，改变的键盘中断为`int 9H`，而读入键盘写入`al`调用的BIOS调用是`int 16H`，指令的输入不会有影响才是。经过网上查找资料，在一篇[CSDN博客](https://blog.csdn.net/ZCMUCZX/article/details/80462394)中，我得知从键盘读入字符和这两个中断都有关。`int 9H`从键盘读入按键的信息将会存在键盘读入的缓冲区中，`int 16H`则从缓冲区中取出信息存入寄存器。二者共同协作，最终成功的读入了键盘并写入了寄存器。当我改变了键盘中断响应的代码，16H中断理所当然从缓冲区得不到字符，造成了无法读取指令的现象。而用户程序不需要读入键盘。因此，我考虑先保存原有艰难盼中断响应的代码的代码段和偏移量，在调用用户程序前把自己的键盘中断响应代码装入键盘中断响应向量，而在用户程序执行完成，返回内核之后，再将原来的键盘中断给恢复。

​		以上方法成功地在内核中避免了键盘中断向量的修改，但在用户程序中，仍然出现了问题："Ouch!Ouch!"不能正常显示出来，也就是调用的我自己写的键盘中断程序有问题。经排查，排除了代码本身的逻辑问题后，我认为可能是原本的键盘中断还实现了其他必要的功能使得中断能够正常执行与退出。在另一篇[博客](https://blog.csdn.net/csdn_blog_lcl/article/details/54926726)中，我发现实现`int 9H`时需要语句`in al 60h`，经查证，键盘按键会存入60h端口，9号中断通读端口获取键盘按键信息。在代码最后加入这一句，键盘中断终于能正确执行。

​		除了本次实验要求的内容之外，我还改进了部分原有的功能。首先是清屏功能，之前的清屏功能，我是使用循环，对屏幕所有区域进行打印，全部都输出黑色背景的空格字符，以此实现清屏的功能。后来在查阅资料的过程中发现了中断号`ah = 6`的`int 10H`BIOS调用，已经实现了屏幕的初始化，即清屏功能。我程序中的清屏模块改为了对该功能的调用。其次是用户程序的跳转和返回。之前的跳转我采用的都是直接`jmp`到相应位置的做法。而据老师说，在操作系统中，用户程序一般是直接`ret`进行返回。经过参考老师发的文件，我采用了使用`call`语句跳转用户程序，用户程序使用`ret`返回的方法。最终的确有效。

